{"version":3,"file":"/packages/autoupdate.js","sources":["autoupdate/autoupdate_cordova.js"],"names":[],"mappings":";;;;;;;;AAAA,gE;AACA,0B;AACA,+B;AACA,E;;AAEA,iD;AACA,4E;AACA,yE;AACA,oE;AACA,sC;AACA,wB;;AAEA,+F;;AAEA,gD;AACA,2E;;AAEA,gB;;AAEA,6C;AACA,oC;AACA,2B;AACA,4C;AACA,K;AACA,E;;AAEA,iE;AACA,6B;AACA,uD;AACA,I;;AAEA,uE;AACA,wC;AACA,gD;AACA,yC;AACA,yC;AACA,2B;AACA,U;AACA,8B;AACA,8B;AACA,e;AACA,M;;AAEA,gC;AACA,mB;AACA,sB;AACA,sB;AACA,W;AACA,E;;AAEA,yC;AACA,iD;AACA,yF;AACA,0E;;AAEA,gB;AACA,gC;AACA,W;AACA,G;;AAEA,8C;AACA,uB;AACA,4B;AACA,qC;AACA,uB;AACA,sC;AACA,a;AACA,I;;AAEA,mD;AACA,+B;AACA,W;AACA,E;;AAEA,4B;AACA,qB;AACA,2B;;AAEA,gC;AACA,8B;AACA,qD;AACA,8D;AACA,4B;AACA,kG;AACA,a;AACA,K;;AAEA,oB;AACA,sE;AACA,K;AACA,E;;AAEA,6C;AACA,qD;AACA,2C;AACA,gC;AACA,8B;;AAEA,uD;;AAEA,gD;;AAEA,iB;AACA,oC;AACA,2B;;AAEA,uB;AACA,mC;;AAEA,oB;AACA,K;;AAEA,mE;AACA,wC;AACA,gB;AACA,qD;AACA,oC;AACA,e;AACA,O;;AAEA,+D;AACA,8C;AACA,qE;AACA,kB;AACA,iD;AACA,iB;AACA,S;;AAEA,mC;AACA,gC;AACA,8D;AACA,kC;AACA,S;AACA,S;AACA,M;;AAEA,6C;AACA,oE;AACA,K;;AAEA,mC;AACA,uD;AACA,qE;AACA,6D;;AAEA,2C;AACA,kB;AACA,mC;AACA,yE;AACA,oB;AACA,4D;AACA,8C;AACA,2B;AACA,sC;AACA,oC;AACA,S;AACA,yB;AACA,mE;AACA,wC;AACA,qE;AACA,wB;AACA,gB;AACA,+G;AACA,S;AACA,S;AACA,M;;AAEA,kB;AACA,I;;AAEA,6E;AACA,gC;AACA,6E;AACA,gB;AACA,0D;AACA,K;AACA,E;;AAEA,uB;AACA,gD;AACA,wC;AACA,G;AACA,iB;;AAEA,6C;AACA,8C;AACA,+D;AACA,6B;AACA,4D;AACA,iB;AACA,8C;AACA,qE;AACA,qE;AACA,wE;AACA,mE;AACA,+D;AACA,wE;AACA,+B;AACA,wC;AACA,S;AACA,K;AACA,K;AACA,uB;AACA,kD;AACA,sB;AACA,qD;AACA,uB;AACA,O;AACA,M;;AAEA,sC;AACA,4B;AACA,gB;AACA,qC;AACA,sC;AACA,O;AACA,G;AACA,E;;AAEA,4B;AACA,iD;AACA,G;AACA,8C;;;AAGA,uE;AACA,sD;AACA,qC;AACA,2E;AACA,uE;AACA,0E;AACA,0D;AACA,4E;AACA,4E;AACA,iC;AACA,4B;AACA,e;AACA,O;;AAEA,qC;AACA,kD;AACA,oC;AACA,iB;;AAEA,0E;AACA,yB;AACA,sE;AACA,oB;AACA,uD;AACA,4C;AACA,kB;AACA,oE;AACA,W;AACA,W;AACA,S;AACA,O;AACA,I;AACA,E;;AAEA,8B;AACA,iD;AACA,oC;AACA,+B;;AAEA,yC;AACA,0D;AACA,sC;AACA,2C;AACA,qB;AACA,wC;AACA,oD;AACA,iC;AACA,S;AACA,sB;AACA,a;AACA,W;AACA,E;;AAEA,0C;AACA,6B;AACA,Y;AACA,I;AACA,0D;AACA,yD;AACA,W;AACA,E;;AAEA,gC;AACA,mD;AACA,E;;AAEA,2C;AACA,0B;AACA,uC;AACA,iE;AACA,6D;AACA,6E;AACA,2E;AACA,4E;AACA,sF;AACA,qE;AACA,Y;AACA,+D;AACA,W;AACA,K;AACA,U;AACA,S;AACA,G;AACA,E","sourcesContent":["var DEBUG_TAG = 'METEOR CORDOVA DEBUG (autoupdate_cordova.js) ';\nvar log = function (msg) {\n  console.log(DEBUG_TAG + msg);\n};\n\n// This constant was picked by testing on iOS 7.1\n// We limit the number of concurrent downloads because iOS gets angry on the\n// application when a certain limit is exceeded and starts timing-out the\n// connections in 1-2 minutes which makes the whole HCP really slow.\nvar MAX_NUM_CONCURRENT_DOWNLOADS = 30;\nvar MAX_RETRY_COUNT = 5;\n\nvar autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Meteor.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne({\n    _id: 'version-cordova',\n    version: {$ne: autoupdateVersionCordova}\n  });\n};\n\nvar writeFile = function (directoryPath, fileName, content, cb) {\n  var fail = function (err) {\n    cb(new Error(\"Failed to write file: \", err), null);\n  };\n\n  window.resolveLocalFileSystemURL(directoryPath, function (dirEntry) {\n    var success = function (fileEntry) {\n      fileEntry.createWriter(function (writer) {\n        writer.onwrite = function (evt) {\n          var result = evt.target.result;\n          cb(null, result);\n        };\n        writer.onerror = fail;\n        writer.write(content);\n      }, fail);\n    };\n\n    dirEntry.getFile(fileName, {\n      create: true,\n      exclusive: false\n    }, success, fail);\n  }, fail);\n};\n\nvar restartServer = function (location) {\n  log('restartServer with location ' + location);\n  var fail = function (err) { log(\"Unexpected error in restartServer: \" + err.message) };\n  var httpd = cordova && cordova.plugins && cordova.plugins.CordovaUpdate;\n\n  if (! httpd) {\n    fail(new Error('no httpd'));\n    return;\n  }\n\n  var startServer = function (cordovajsRoot) {\n    httpd.startServer({\n      'www_root' : location,\n      'cordovajs_root': cordovajsRoot\n    }, function (url) {\n      Package.reload.Reload._reload();\n    }, fail);\n  };\n\n  httpd.getCordovajsRoot(function (cordovajsRoot) {\n    startServer(cordovajsRoot);\n  }, fail);\n};\n\nvar hasCalledReload = false;\nvar updating = false;\nvar localPathPrefix = null;\n\nvar onNewVersion = function () {\n  var ft = new FileTransfer();\n  var urlPrefix = Meteor.absoluteUrl() + '__cordova';\n  HTTP.get(urlPrefix + '/manifest.json', function (err, res) {\n    if (err || ! res.data) {\n      log('Failed to download the manifest ' + (err && err.message) + ' ' + (res && res.content));\n      return;\n    }\n\n    updating = true;\n    ensureLocalPathPrefix(_.bind(downloadNewVersion, null, res.data));\n  });\n};\n\nvar downloadNewVersion = function (program) {\n  var urlPrefix = Meteor.absoluteUrl() + '__cordova';\n  var manifest = _.clone(program.manifest);\n  var version = program.version;\n  var ft = new FileTransfer();\n\n  manifest.push({ url: '/index.html?' + Random.id() });\n\n  var versionPrefix = localPathPrefix + version;\n\n  var queue = [];\n  _.each(manifest, function (item) {\n    if (! item.url) return;\n\n    var url = item.url;\n    url = url.replace(/\\?.+$/, '');\n\n    queue.push(url);\n  });\n\n  var afterAllFilesDownloaded = _.after(queue.length, function () {\n    var wroteManifest = function (err) {\n      if (err) {\n        log(\"Failed to write manifest.json: \" + err);\n        // XXX do something smarter?\n        return;\n      }\n\n      // success! downloaded all sources and saved the manifest\n      // save the version string for atomicity\n      writeFile(localPathPrefix, 'version', version, function (err) {\n        if (err) {\n          log(\"Failed to write version: \" + err);\n          return;\n        }\n\n        // don't call reload twice!\n        if (! hasCalledReload) {\n          var location = uriToPath(localPathPrefix + version);\n          restartServer(location);\n        }\n      });\n    };\n\n    writeFile(versionPrefix, 'manifest.json',\n              JSON.stringify(program, undefined, 2), wroteManifest);\n  });\n\n  var dowloadUrl = function (url) {\n    console.log(DEBUG_TAG + \"start dowloading \" + url);\n    // Add a cache buster to ensure that we don't cache an old asset.\n    var uri = encodeURI(urlPrefix + url + '?' + Random.id());\n\n    // Try to dowload the file a few times.\n    var tries = 0;\n    var tryDownload = function () {\n      ft.download(uri, versionPrefix + encodeURI(url), function (entry) {\n        if (entry) {\n          console.log(DEBUG_TAG + \"done dowloading \" + url);\n          // start downloading next queued url\n          if (queue.length)\n            dowloadUrl(queue.shift());\n          afterAllFilesDownloaded();\n        }\n      }, function (err) {\n        // It failed, try again if we have tried less than 5 times.\n        if (tries++ < MAX_RETRY_COUNT) {\n          log(\"Download error, will retry (#\" + tries + \"): \" + uri);\n          tryDownload();\n        } else {\n          log('Download failed: ' + JSON.stringify(err) + \", source=\" + err.source + \", target=\" + err.target);\n        }\n      });\n    };\n\n    tryDownload();\n  };\n\n  _.times(Math.min(MAX_NUM_CONCURRENT_DOWNLOADS, queue.length), function () {\n    var nextUrl = queue.shift();\n    // XXX defer the next download so iOS doesn't rate limit us on concurrent\n    // downloads\n    Meteor.setTimeout(dowloadUrl.bind(null, nextUrl), 50);\n  });\n};\n\nvar retry = new Retry({\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n  var appId = __meteor_runtime_config__.appId;\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", appId, {\n    onError: function (err) {\n      Meteor._debug(\"autoupdate subscription failed:\", err);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    }\n  });\n  if (Package.reload) {\n    var checkNewVersionDocument = function (doc) {\n      var self = this;\n      if (doc.version !== autoupdateVersionCordova) {\n        onNewVersion();\n      }\n    };\n\n    var handle = ClientVersions.find({\n      _id: 'version-cordova'\n    }).observe({\n      added: checkNewVersionDocument,\n      changed: checkNewVersionDocument\n    });\n  }\n};\n\nMeteor.startup(function () {\n  clearAutoupdateCache(autoupdateVersionCordova);\n});\nMeteor.startup(Autoupdate._retrySubscription);\n\n\n// A helper that removes old directories left from previous autoupdates\nvar clearAutoupdateCache = function (currentVersion) {\n  ensureLocalPathPrefix(function () {\n    // Try to clean up our cache directory, make sure to scan the directory\n    // *before* loading the actual app. This ordering will prevent race\n    // conditions when the app code tries to download a new version before\n    // the old-cache removal has scanned the cache folder.\n    listDirectory(localPathPrefix, {dirsOnly: true}, function (err, names) {\n      // Couldn't get the list of dirs or risking to get into a race with an\n      // on-going update to disk.\n      if (err || updating) {\n        return;\n      }\n\n      _.each(names, function (name) {\n        // Skip the folder with the latest version\n        if (name === currentVersion)\n          return;\n\n        // remove everything else, as we don't want to keep too much cache\n        // around on disk\n        removeDirectory(localPathPrefix + name + '/', function (err) {\n          if (err) {\n            log('Failed to remove an old cache folder '\n                + name + ':' + err.message);\n          } else {\n            log('Successfully removed an old cache folder ' + name);\n          }\n        });\n      });\n    });\n  })\n};\n\n// Cordova File plugin helpers\nvar listDirectory = function (url, options, cb) {\n  if (typeof options === 'function')\n    cb = options, options = {};\n\n  var fail = function (err) { cb(err); };\n  window.resolveLocalFileSystemURL(url, function (entry) {\n    var reader = entry.createReader();\n    reader.readEntries(function (entries) {\n      var names = [];\n      _.each(entries, function (entry) {\n        if (! options.dirsOnly || entry.isDirectory)\n          names.push(entry.name);\n      });\n      cb(null, names);\n    }, fail);\n  }, fail);\n};\n\nvar removeDirectory = function (url, cb) {\n  var fail = function (err) {\n    cb(err);\n  };\n  window.resolveLocalFileSystemURL(url, function (entry) {\n    entry.removeRecursively(function () { cb(); }, fail);\n  }, fail);\n};\n\nvar uriToPath = function (uri) {\n  return decodeURI(uri).replace(/^file:\\/\\//g, '');\n};\n\nvar ensureLocalPathPrefix = function (cb) {\n  if (! localPathPrefix) {\n    if (! cordova.file.dataDirectory) {\n      // Since ensureLocalPathPrefix function is always called on\n      // Meteor.startup, all Cordova plugins should be ready.\n      // XXX Experiments have shown that it is not always the case, even when\n      // the cordova.file symbol is attached, properties like dataDirectory\n      // still can be null. Poll until we are sure the property is attached.\n      console.log(DEBUG_TAG + 'cordova.file.dataDirectory is null, retrying in 20ms');\n      Meteor.setTimeout(_.bind(ensureLocalPathPrefix, null, cb), 20);\n    } else {\n      localPathPrefix = cordova.file.dataDirectory + 'meteor/';\n      cb();\n    }\n  } else {\n    cb();\n  }\n};\n\n"]}